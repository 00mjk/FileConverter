// <copyright file="ConversionJob.cs" company="AAllard">License: http://www.gnu.org/licenses/gpl.html GPL version 3.</copyright>

namespace FileConverter.ConversionJobs
{
    using System;
    using System.ComponentModel;
    using System.Runtime.CompilerServices;
    using System.Text;

    public class ConversionJob : INotifyPropertyChanged
    {
        private float progress = 0f;
        private ConversionState state = ConversionState.Unknown;
        private string errorMessage = string.Empty;
        private string initialInputPath = string.Empty;

        public ConversionJob()
        {
            this.State = ConversionState.Unknown;
            this.ConversionPreset = null;
            this.InputFilePath = string.Empty;
        }

        public ConversionJob(ConversionPreset conversionPreset) : this()
        {
            if (conversionPreset == null)
            {
                throw new ArgumentNullException("conversionPreset");
            }

            this.ConversionPreset = conversionPreset;
        }

        public event PropertyChangedEventHandler PropertyChanged;

        public enum ConversionState
        {
            Unknown,

            Ready,
            InProgress,
            Done,
            Failed,
        }

        public ConversionPreset ConversionPreset
        {
            get;
            private set;
        }

        public string InputFilePath
        {
            get;
            private set;
        }

        public string OutputFilePath
        {
            get;
            private set;
        }
        
        public ConversionState State
        {
            get
            {
                return this.state;
            }

            private set
            {
                this.state = value;
                this.NotifyPropertyChanged();
            }
        }

        public float Progress
        {
            get
            {
                return this.progress;
            }

            protected set
            {
                this.progress = value;
                this.NotifyPropertyChanged();
            }
        }

        public string ErrorMessage
        {
            get
            {
                return this.errorMessage;
            }

            private set
            {
                this.errorMessage = value;
                this.NotifyPropertyChanged();
            }
        }

        public void PrepareConversion(string inputFilePath)
        {
            if (string.IsNullOrEmpty(inputFilePath))
            {
                throw new ArgumentNullException("inputFilePath");
            }

            if (this.ConversionPreset == null)
            {
                throw new Exception("The conversion preset must be valid.");
            }

            this.initialInputPath = inputFilePath;
            this.InputFilePath = inputFilePath;
            this.OutputFilePath = this.ConversionPreset.GenerateOutputFilePath(inputFilePath);
            
            if (!PathHelpers.IsPathValid(this.OutputFilePath))
            {
                this.ConvertionFailed("Invalid output path generated by output file path template.");
                Diagnostics.Log(string.Format("Invalid output path generated: {0} from input: {1}.", this.OutputFilePath, this.InputFilePath));
                return;
            }

            if (this.OutputFilePath == this.InputFilePath)
            {
                // If the input post conversion action is to move or delete the input file, change its name in order to keep the output name intact.
                if (this.ConversionPreset.InputPostConversionAction == InputPostConversionAction.MoveInArchiveFolder ||
                    this.ConversionPreset.InputPostConversionAction == InputPostConversionAction.Delete)
                {
                    string inputExtension = System.IO.Path.GetExtension(this.InputFilePath);
                    string pathWithoutExtension = this.InputFilePath.Substring(0, this.InputFilePath.Length - inputExtension.Length);
                    this.InputFilePath = PathHelpers.GenerateUniquePath(pathWithoutExtension + "_TEMP" + inputExtension);
                    System.IO.File.Move(inputFilePath, this.InputFilePath);
                }
            }

            // Create output folder that doesn't exist.
            {
                StringBuilder path = new StringBuilder(this.OutputFilePath.Length);
                foreach (string directory in PathHelpers.GetDirectories(this.OutputFilePath))
                {
                    path.Append(directory);
                    path.Append('\\');

                    if (!System.IO.Directory.Exists(path.ToString()))
                    {
                        try
                        {
                            System.IO.Directory.CreateDirectory(path.ToString());
                        }
                        catch (Exception)
                        {
                            this.ConvertionFailed("Invalid output path generated by output file path template.");
                            Diagnostics.Log(string.Format("Can't create directories for path {0}", this.OutputFilePath));
                            return;
                        }
                    }
                }
            }

            // Make the output path valid.
            try
            {
                this.OutputFilePath = PathHelpers.GenerateUniquePath(this.OutputFilePath);
            }
            catch (Exception exception)
            {
                this.ConvertionFailed("Can't generate a valid output filename.");
                Diagnostics.Log(exception.Message);
                return;
            }
            
            this.Initialize();

            if (this.State == ConversionState.Unknown)
            {
                this.State = ConversionState.Ready;
            }
        }

        public void StartConvertion()
        {
            if (this.ConversionPreset == null)
            {
                throw new Exception("The conversion preset must be valid.");
            }

            if (this.State != ConversionState.Ready)
            {
                throw new Exception("Invalid conversion state.");
            }

            Diagnostics.Log("Convert file {0} to {1}.", this.InputFilePath, this.OutputFilePath);

            this.State = ConversionState.InProgress;

            this.Convert();

            if (this.State != ConversionState.Failed)
            {
                this.OnConversionSucceed();
            }
        }

        protected virtual void Convert()
        {
        }

        protected virtual void Initialize()
        {
        }

        protected virtual void OnConversionSucceed()
        {
            Diagnostics.Log("Conversion Succeed!");

            // Apply the input post conversion action.
            switch (this.ConversionPreset.InputPostConversionAction)
            {
                case InputPostConversionAction.None:
                    break;

                case InputPostConversionAction.MoveInArchiveFolder:
                    string basePath = System.IO.Path.GetDirectoryName(this.initialInputPath);
                    string inputFilename = System.IO.Path.GetFileName(this.initialInputPath);
                    string archivePath = basePath + "\\" + this.ConversionPreset.ConversionArchiveFolderName;
                    if (!System.IO.Directory.Exists(archivePath))
                    {
                        System.IO.Directory.CreateDirectory(archivePath);
                    }

                    string newPath = PathHelpers.GenerateUniquePath(archivePath + "\\" + inputFilename);
                    System.IO.File.Move(this.InputFilePath, newPath);
                    Diagnostics.Log("Input file moved in archive folder: '{0}'", newPath);
                    break;

                case InputPostConversionAction.Delete:
                    System.IO.File.Delete(this.InputFilePath);
                    Diagnostics.Log("Input file deleted: '{0}'", this.initialInputPath);
                    break;
            }

            Diagnostics.Log(string.Empty);

            this.Progress = 1f;
            this.State = ConversionState.Done;
            Diagnostics.Log("Conversion Done!");
        }

        protected void ConvertionFailed(string exitingMessage)
        {
            this.State = ConversionState.Failed;
            this.ErrorMessage = exitingMessage;
        }

        protected void NotifyPropertyChanged([CallerMemberName] string propertyName = "")
        {
            if (this.PropertyChanged != null)
            {
                this.PropertyChanged(this, new PropertyChangedEventArgs(propertyName));
            }
        }
    }
}
